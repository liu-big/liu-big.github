[{"title":"Hello World","url":"/2025/07/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"嵌入式Linux多媒体中心项目介绍","url":"/2025/07/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"I. 项目背景与意义随着嵌入式设备（如智能家居终端、车载信息系统、便携式娱乐设备）的普及，用户对小型化设备的多媒体交互需求日益增长。然而，多数嵌入式设备受限于硬件资源（低主频CPU、有限内存、小尺寸触摸屏），难以运行Qt、GTK等重量级图形库，导致界面简陋、功能单一。\n本项目的核心价值在于：在资源受限的嵌入式Linux环境下，通过底层技术突破，实现轻量化、高性能的多媒体交互系统。它不仅满足了用户对电子相册、电子书、电子琴等娱乐功能的需求，更提供了一套可复用的嵌入式GUI开发框架，为同类设备的界面开发提供了参考范例，展现了“从0到1”构建底层图形系统的技术可行性。\nII. 项目概述本项目是一个基于嵌入式Linux平台的综合性多媒体应用程序，旨在为带有触摸屏的嵌入式设备（如开发板）提供功能丰富、界面美观、交互友好的图形化操作环境。系统完全采用C语言从底层构建，不依赖任何高级图形库（如Qt、GTK），通过直接操作Linux Framebuffer（帧缓冲）实现UI的绘制与刷新，完整展现了资源受限环境下嵌入式GUI应用开发的全流程。\n项目核心整合了电子相册、电子书阅读器和迷你电子琴三大主流多媒体功能，并通过精心设计的现代化主菜单进行导航。开发过程不仅包含功能实现，更经历了UI&#x2F;UX优化、代码重构、功能迭代和问题调试，最终呈现为稳定、高效且用户体验良好的完整系统。\nIII. 系统环境与依赖1. 硬件环境\n开发板：支持Linux系统的嵌入式开发板（如友善之臂Tiny4412、树莓派等）\n处理器：ARM架构CPU（主频≥1GHz，支持硬件浮点运算）\n内存：≥256MB（用于图片解码、音频缓存及UI渲染）\n存储：≥1GB（用于存储图片、电子书、音频等多媒体文件）\n显示屏：800x480分辨率触摸屏（支持单点触摸输入）\n\n2. 软件环境\n操作系统：Linux内核（≥3.0，支持Framebuffer设备驱动）\n交叉编译工具链：arm-linux-gnueabihf-gcc（用于在PC端编译嵌入式程序）\n依赖库：\nlibjpeg：用于JPEG图片解码\nmpg123：轻量级音频播放器（用于电子琴音效播放）\n\n\n字库文件：HZK16（16x16点阵中文字库）、ASC16（16x16点阵英文字库）\n\nIV. 核心功能模块详解1. 主菜单 (Main Menu)主菜单是用户与系统交互的入口，设计直接影响产品整体感受。\n\n设计演进：初期为简单垂直列表，布局单调；优化后采用现代化“四方格”2x2网格布局，高效利用800x480屏幕空间，用户可一步点击进入任何核心模块。\n视觉实现：背景为深邃蓝色（0x002C3E50），营造科技感；功能格采用高对比度色彩（绿色、紫色、红色），搭配居中中文标题，视觉冲击力强，功能一目了然。\n交互优化：触摸响应区域覆盖整个功能格（边缘预留5px容错区），点击时会显示0.2秒的高亮反馈（颜色加深10%），提升操作确认感。\n\n2. 电子相册 (Photo Album)功能完备的图片浏览模块，支持常见图片格式。\n\n核心功能：\n格式支持：解码并显示BMP（无压缩位图）和JPEG（有损压缩）两种主流格式。\n图片浏览：通过侧边栏按钮实现“上一张”“下一张”循环浏览；后台用双向链表管理图片文件列表，切换效率达O(1)。\n动态缩放：支持20%步进的无级缩放（0.2x ~ 4.0x），缩放算法采用双线性插值，兼顾效率与画质。\n\n\nUI与交互：\n左侧100px宽控制面板与主显示区分离，按钮采用“图标+文字”组合（如“← 上一张”）。\n顶部信息栏实时显示文件名（如“风景.jpg”）和缩放比例（如“1.2x”），支持超长文件名自动截断（末尾加“…”）。\n\n\n\n3. 电子书阅读器 (E-Book Reader)提供舒适的中文文本阅读环境。\n\n核心功能：\n中英文混合渲染：完美支持GB2312编码的中英文混合文本，英文用ASC16字库，中文用HZK16字库。\n自动分页：根据屏幕尺寸（800x480）和字体大小（16px），自动计算每页行数（28行）和每行字符数（中50个&#x2F;英100个），实现精准分页。\n翻页与跳转：支持“上一页&#x2F;下一页”翻页（通过fseek定位文件偏移量），以及“上一章&#x2F;下一章”跳转（基于文件内“第X章”标记识别）。\n\n\nUI与交互：\n右侧控制栏动态绘制，包含翻页按钮和章节选择器，支持滑动切换章节。\n背景为米白色（0xFFF8E1），降低视觉疲劳；左下角显示“第3章 - 第5页”进度信息，支持手动输入页码跳转。\n\n\n\n4. 迷你电子琴 (Mini Piano)互动性强的音乐模块，功能经创新性迭代。\n\n功能演进：初期设计为“录音+回放”模式，后替换为**“乐曲演奏示例”**功能，简化操作并提升展示效果。\n最终功能：\n自由弹奏：12个琴键对应12个音符（C4~B4），触摸时通过mpg123播放对应音效（.mp3格式），响应延迟≤100ms。\n自动演奏示例：点击“演奏示例”后自动弹奏《小星星》，弹奏时琴键同步高亮（红色闪烁），实现音画同步；乐曲逻辑通过音符-时间戳数组实现（如[&#123;note: C4, delay: 500&#125;, ...]）。\n\n\nUI设计：琴键采用黑白相间的钢琴配色，白键宽60px、黑键宽40px，间距5px，符合真实钢琴比例。\n\nV. 技术架构与实现亮点1. 底层图形驱动\n直接操作Framebuffer设备（/dev/fb0），通过open打开设备后，用mmap将显存映射到用户空间内存（如800x480x2字节&#x3D;768KB），通过指针直接读写像素数据（RGB565格式），效率比调用图形库高30%以上。\n核心函数：init_lcd()（初始化映射）、lcd_draw_pixel()（画点）、lcd_refresh()（刷新屏幕）。\n\n2. 自研微型UI引擎\n原子绘制函数：实现lcd_draw_rect（矩形）、lcd_draw_circle（圆形）、lcd_draw_line（直线）等基础图形函数，支持填充与描边模式。\n文本渲染核心：draw_string_centered函数通过区分ASCII码（&lt;128）和中文（≥128），计算混合字符串总宽度，实现矩形区域内精准居中；支持文本换行与对齐（左&#x2F;中&#x2F;右）。\n事件处理机制：通过读取触摸屏设备（/dev/input/event0），解析触摸坐标（x,y）和状态（按下&#x2F;抬起），映射到UI元素（按钮、琴键），实现交互响应。\n\n3. 多媒体处理方案\n图像解码：\nBMP：通过解析文件头（14字节）和信息头（40字节），直接提取像素数据并映射到Framebuffer。\nJPEG：集成libjpeg库，通过jpeg_create_decompress等函数解码，将YUV数据转换为RGB565格式后显示。\n\n\n音频播放：采用popen创建mpg123进程，通过管道发送命令（如load C4.mp3）控制播放，实现主程序与音频播放的异步并行，避免阻塞UI。\n\n4. 问题调试与优化\n编译问题：解决BTN_X宏与系统头文件冲突（重命名为KEY_X）、重复文件main（复件）.c导致的链接错误（删除冗余文件）。\n运行时问题：\n中文乱码：因源文件UTF-8编码与HZK16（GB2312）不匹配，通过iconv工具将文本转为GB2312解决。\n图片显示错位：因JPEG解码后尺寸与屏幕不匹配，添加自动居中算法（计算偏移量(800 - img_w)/2）。\n\n\n性能优化：通过双缓冲机制（前台显示+后台绘制）消除画面闪烁，将UI刷新帧率稳定在30fps以上。\n\nVI. 项目管理与开发流程项目采用迭代开发模式，分为4个阶段：\n\n原型阶段（1周）：实现主菜单与核心功能雏形，验证技术可行性。\n功能完善阶段（2周）：完成图片&#x2F;文本&#x2F;音频的完整功能，解决解码与显示问题。\nUI&#x2F;UX优化阶段（1周）：优化布局、色彩和交互反馈，提升用户体验。\n测试与重构阶段（1周）：进行压力测试（如连续浏览100张图片），重构冗余代码（如合并重复的绘制函数）。\n\n版本控制采用Git，分支策略为：main（稳定版）、dev（开发版）、feature/*（功能分支），确保代码管理清晰。\nVII. 总结与未来展望项目价值本项目不仅是一个功能完整的嵌入式多媒体中心，更展现了在资源受限环境下开发底层GUI的全流程：从Framebuffer操作到自研UI引擎，从多媒体解码到交互优化，为嵌入式开发者提供了可复用的技术方案和实践经验。\n未来展望\n功能扩展：增加视频播放器（基于ffmpeg）、天气预报（联网获取数据）等模块。\n性能优化：引入硬件加速（如GPU渲染），支持更高分辨率屏幕（1080P）。\n交互升级：支持多点触摸（如图片缩放用双指捏合）、手势识别（如滑动翻页）。\n可移植性：适配更多嵌入式平台（如RISC-V架构），扩展应用场景。\n\n通过持续迭代，本项目有望从“多媒体中心”升级为更全面的“嵌入式智能交互终端”，为小型化设备提供更丰富的用户体验。\n"},{"title":"ROS机器人项目（Ucar）故障排查与解决方案","url":"/2025/07/25/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A1%B9%E7%9B%AE%EF%BC%88Ucar%EF%BC%89%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"ROS机器人项目（Ucar）故障排查与解决方案文档引言本文档全面总结Ucar ROS机器人项目的复杂故障排查过程，涵盖从C++代码逻辑错误、内存管理问题到嵌入式系统（Rockchip主板）图形驱动与ROS网络配置问题的完整解决方案。记录每个问题的症状、根本原因、解决方案及相关指令，形成可供参考的调试经验。\n问题一：音频播放失败（”文件未找到”）症状节点播放唤醒音或回复音时出现错误：\nplay FAIL formats: can&#x27;t open input file &#x27;/audio/wakeup.wav&#x27;: No such file or directory\n\n根本原因程序代码使用硬编码绝对路径（/audio/wakeup.wav），系统从文件系统根目录查找，而非ROS功能包相对路径，导致查找失败。\n解决方案修改C++代码，动态获取功能包绝对路径并与音频文件相对路径拼接。\n推荐代码实现（以AIUITester.cpp中的process_recv函数为例）// 1. 包含头文件#include &lt;ros/package.h&gt;// 2. 构建完整路径std::string package_path = ros::package::getPath(&quot;speech_command&quot;);if (!package_path.empty()) &#123;    // WAKEUP_RESPONSE_WAV 是Global.h中定义的相对路径 &quot;/audio/wakeup.wav&quot;    std::string wav_path = package_path + WAKEUP_RESPONSE_WAV;    std::string command = &quot;play &quot; + wav_path;    system(command.c_str());&#125;\n\n问题二：音频播放失败（”无法确定文件类型”）症状解决”文件未找到”问题后，出现新错误：\nplay FAIL formats: can&#x27;t determine type of file &#x27;/home/ucar/ucar_ws/src/speech_command&#x27;\n\n根本原因语音识别结果在offline_QA.txt配置文件中无完全匹配条目，导致FindDocument()函数返回空字符串，路径拼接后仅剩功能包路径（目录），程序试图播放目录而非音频文件。\n解决方案数据层面检查并确保config/offline_QA.txt包含所有需响应的语音指令，且与程序识别文本（含标点）完全对应。\n代码层面增加代码健壮性，在播放音频前检查文件路径是否为空。\n推荐代码实现（aiuiMain.cpp的data_send函数）string document = FindDocument(question_str);// 增加路径非空判断if (!document.empty()) &#123;    string ros_package_path1 = ros::package::getPath(&quot;speech_command&quot;);    std::string wav_path1 = ros_package_path1 + document;    std::string command1 = &quot;play &quot; + wav_path1;    system(command1.c_str());&#125; else &#123;    cout &lt;&lt; &quot;未找到问题对应的音频文件: &quot; &lt;&lt; question_str &lt;&lt; endl;&#125;\n\n问题三：节点启动时崩溃（音频设备占用与内存错误）症状roslaunch启动时节点异常退出，关键错误：\n\n无法打开音频设备: 2,0 (Device or resource busy)\nfree(): double free detected in tcache 2![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b632e52495b14ac5a6979868fae0c327.png\n\n根本原因设备占用另一进程（如其他ROS节点、系统服务）占用程序所需音频设备（实际为hw:XFMDPV0018，日志打印存在误导）。\n内存错误AIUITester.cpp中使用audioRecorder-&gt;~AudioRecorder();非标准方式调用析构函数，导致内存重复释放。\n解决方案设备占用\n在机器人终端使用fuser -v /dev/snd/*命令查找并kill占用音频设备的进程。\n（可选）修正AIUITester.cpp中的printf语句，打印正确设备名pcm_name。\n\n内存错误修改AIUITester.cpp的destory函数，使用标准delete关键字释放对象。\n代码修正// 在 AIUITester::destory() 中// 修改前: audioRecorder-&gt;~AudioRecorder();// 修改后: delete audioRecorder;\n\n问题四：RViz启动失败（图形驱动与主机名解析）\n阶段A：RViz因图形驱动不兼容崩溃症状启动RViz时出现libGL error: unable to load driver: rockchip_dri.so错误并伴随Segmentation fault段错误。\n根本原因Ucar机器人嵌入式环境（Rockchip主板）缺少或无法加载RViz依赖的3D硬件加速驱动；启动文件ucar_gmapping.launch错误包含本地启动RViz的节点。\n解决方案\n修改启动文件：编辑~/ucar_ws/src/ucar_map/launch/ucar_gmapping.launch，注释掉RViz节点。\n采用”PC端远程可视化”方案（ROS开发标准工作流程）。\n\n阶段B：RViz在PC端启动但无法显示数据症状PC端RViz启动成功但不显示机器人数据，报错：\nCouldn&#x27;t find an AF_INET address for [superbrain]: 域名解析暂时失败\n\n\n根本原因PC操作系统不识别机器人主机名superbrain，无法解析为IP地址，导致节点通信失败。\n解决方案方法1（推荐）：设置ROS_IP（机器人端）# 启动roscore终端export ROS_IP=&lt;机器人IP地址&gt;roscore# 启动主程序终端export ROS_IP=&lt;机器人IP地址&gt;roslaunch ucar_map ucar_gmapping.launch\n\n方法2（备选）：手动映射主机名到IP\nLinux&#x2F;Mac：编辑/etc/hosts\nWindows：以管理员身份编辑C:\\Windows\\System32\\drivers\\etc\\hosts添加：192.168.141.32 superbrain（IP替换为机器人实际IP）\n\n问题五：ROS网络核心roscore启动失败症状机器人运行roscore时报错：\nRLException: Unable to contact my own server at [...]\n\n根本原因机器人环境变量ROS_IP设置为过时或错误IP（可能固化在~/.bashrc中），导致roscore无法自通信。\n解决方案\n临时取消设置：unset ROS_IP和unset ROS_HOSTNAME。\n检查并编辑~/.bashrc：nano ~/.bashrc，注释掉export ROS_IP=...行。\n刷新配置：source ~/.bashrc。\n\n总结与最佳实践核心开发原则\n计算与可视化分离嵌入式项目中，计算密集型无界面节点（驱动、算法）运行在机器人上，图形工具（RViz、rqt_plot）运行在PC端。\n稳健的网络配置多机通信优先使用IP地址配置（通过ROS_IP和ROS_MASTER_URI），避免主机名解析失败导致通信中断。\n规范的编码与内存管理遵循C++标准内存管理（new/delete配对），避免非规范操作（如手动调用析构函数）。\n系统性调试思路从日志入手，逐层分析（应用层代码逻辑→环境层驱动&#x2F;网络），定位问题时采用”排除法”缩小范围。\n\n额外建议\n定期检查系统资源占用（如音频设备、端口），使用fuser、lsof等工具排查冲突。\n维护清晰的环境变量配置，避免在.bashrc中固化静态IP，改为动态设置。\n开发阶段保留详细调试日志，便于复现和追溯问题。\n\n"},{"title":"通过 WebSocket 实时获取 ROS 机器人数据","url":"/2025/07/25/%E9%80%9A%E8%BF%87-WebSocket-%E5%AE%9E%E6%97%B6%E8%8E%B7%E5%8F%96-ROS-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%95%B0%E6%8D%AE/","content":"从零开始：通过 WebSocket 实时获取 ROS 机器人数据 (小白终极教程)前言本教程旨在帮助初学者解决一个常见的需求：如何从一台运行ROS（机器人操作系统）的机器人上，将实时数据（例如IMU、里程计、摄像头等）传输到另一台普通的电脑上，并用Python等通用编程语言进行处理。\n我们将使用rosbridge这个强大的工具，它就像一座桥梁，将ROS复杂的通信协议转换成大家所熟知的WebSocket协议，让非ROS程序也能轻松与机器人交互。\n核心架构在开始之前，我们先理清整个数据流动的路径，这会让你对接下来的步骤有更清晰的认识：\n机器人端 (数据发送方) → 客户端 (数据接收方)机器人节点 (如/base_driver) → 发布 /imu 话题 → ROS Master (核心) → rosbridge_server (运行在机器人上) → 局域网 (Wi-Fi) → 你的电脑 (运行Python脚本) → 成功接收数据\n\n这里的关键点是：rosbridge_server必须和你的机器人节点运行在同一台设备上！\n第一部分：机器人端配置 (以 IP: 192.168.9.32 为例)这部分的所有操作都在你的机器人或装有ROS的主控电脑上进行。\n第1步：确定并记录机器人的IP地址这是所有网络通信的基础。打开一个终端，输入以下命令之一：\nifconfig# 或者ip addr\n\n在输出的信息中找到你的主网络接口（通常是wlan0, wlp3s0等无线网卡，或是eth0, enp4s0等有线网卡），记下它的inet地址。在本案例中，我们确定了机器人IP是192.168.9.32。\n第2步：安装rosbridge_server如果你的机器人上没有安装过，请在终端中运行：\nsudo apt-get updatesudo apt-get install ros-noetic-rosbridge-server\n\n(请将noetic替换成你对应的ROS版本，如melodic)\n第3步：启动并验证数据源（IMU话题）确保你的机器人底盘驱动或传感器节点已经正常运行。这是数据的源头，必须先启动。\n启动机器人节点 (请替换成你自己的命令):\nroslaunch my_robot_control robot_start.launch\n\n验证 &#x2F;imu 话题是否正常发布 (非常关键的检查步骤):打开一个新的终端，输入：\nrostopic info /imu\n\n如果你看到类似下面的输出，特别是Publishers:部分不为空，说明数据源正常。\nType: sensor_msgs/ImuPublishers:  * /base_driver (http://192.168.9.32:38583/)...\n\n第4步：配置并启动rosbridge_server找到并编辑launch文件，将其监听的IP地址配置为机器人的IP。\nroscd rosbridge_server/launch/sudo cp rosbridge_websocket.launch rosbridge_websocket.launch.backup # 备份是个好习惯sudo gedit rosbridge_websocket.launch\n\n在打开的文件中，找到 &lt;param name=&quot;address&quot; ... /&gt; 这一行，将其value修改为你在第1步中查到的机器人IP地址。\n&lt;param name=&quot;address&quot; value=&quot;192.168.9.32&quot; /&gt;\n\n为何要这样做？默认情况下rosbridge可能只监听本地127.0.0.1，修改为局域网IP后，网络内的其他设备才能访问到它。\n启动rosbridge_server:\nroslaunch rosbridge_server rosbridge_websocket.launch\n\n此时，你的机器人端已经准备就绪。它正在发布 &#x2F;imu 数据，并且rosbridge正在将这些数据通过 ws://192.168.9.32:9090 这个地址向全网络广播。\n第二部分：客户端配置 (你的电脑)这部分操作在你自己的电脑（例如笔记本）上进行。\n第1步：准备Python环境安装pip (如果还没有):\nsudo apt-get updatesudo apt-get install python3-pip\n\n安装websocket-client库:\npip3 install websocket-client\n\n第2步：编写并配置Python脚本在你电脑上创建一个名为test.py的文件，将以下代码完整地复制进去：\nimport websocketimport jsonimport timedef on_message(ws, message):    &quot;&quot;&quot;当接收到消息时此函数被调用&quot;&quot;&quot;    try:        data = json.loads(message)        # 检查消息中是否包含 &#x27;msg&#x27; 字段，这通常是rosbridge话题数据的结构        if &quot;msg&quot; in data:            imu_data = data[&#x27;msg&#x27;]            # 提取并打印线加速度数据            if &#x27;linear_acceleration&#x27; in imu_data:                x = imu_data[&#x27;linear_acceleration&#x27;][&#x27;x&#x27;]                y = imu_data[&#x27;linear_acceleration&#x27;][&#x27;y&#x27;]                z = imu_data[&#x27;linear_acceleration&#x27;][&#x27;z&#x27;]                timestamp = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())                print(f&quot;[&#123;timestamp&#125;] [IMU Data] x=&#123;x:.4f&#125;, y=&#123;y:.4f&#125;, z=&#123;z:.4f&#125;&quot;)    except json.JSONDecodeError as e:        print(f&quot;[JSON解析错误] &#123;e&#125;: &#123;message&#125;&quot;)def on_error(ws, error):    &quot;&quot;&quot;当发生错误时此函数被调用&quot;&quot;&quot;    print(f&quot;[WebSocket错误]: &#123;error&#125;&quot;)def on_close(ws, close_status_code, close_msg):    &quot;&quot;&quot;当连接关闭时此函数被调用&quot;&quot;&quot;    print(&quot;WebSocket连接已关闭&quot;)    print(f&quot;状态码: &#123;close_status_code&#125;, 消息: &#123;close_msg&#125;&quot;)def on_open(ws):    &quot;&quot;&quot;当连接建立时此函数被调用&quot;&quot;&quot;    print(&quot;WebSocket连接已建立&quot;)    # 构建订阅消息    subscribe_message = &#123;        &quot;op&quot;: &quot;subscribe&quot;,        &quot;topic&quot;: &quot;/imu&quot;,  # 订阅的话题名称        &quot;throttle_rate&quot;: 100,  # 限制消息发布频率为100ms        &quot;queue_length&quot;: 10,    # 队列长度为10        &quot;compression&quot;: &quot;cbor&quot;  # 使用CBOR压缩以减少带宽    &#125;    # 发送订阅请求    ws.send(json.dumps(subscribe_message))    print(f&quot;已订阅话题: /imu&quot;)if __name__ == &quot;__main__&quot;:    # 设为True可以看到详细的底层通信日志，用于调试    websocket.enableTrace(False)      # --- !!! 请务必修改为你机器人端的真实IP地址 !!! ---    ws_url = &quot;ws://192.168.9.32:9090&quot;      print(f&quot;正在连接到 &#123;ws_url&#125;...&quot;)      # 创建WebSocketApp对象并设置回调函数    ws = websocket.WebSocketApp(        ws_url,        on_open=on_open,        on_message=on_message,        on_error=on_error,        on_close=on_close    )      # 设置断线重连机制    reconnect_interval = 5  # 断线后等待5秒重试    while True:        try:            # 启动WebSocket客户端            ws.run_forever()        except Exception as e:            print(f&quot;发生异常: &#123;e&#125;&quot;)            print(f&quot;&#123;reconnect_interval&#125;秒后尝试重连...&quot;)            time.sleep(reconnect_interval)\n\n第3步：运行脚本，见证奇迹在test.py文件所在的目录打开终端，运行：\npython3 test.py\n\n如果一切顺利，你将看到：\n正在连接到 ws://192.168.9.32:9090...WebSocket连接已建立已订阅话题: /imu[2023-01-01 12:00:00] [IMU Data] x=0.0123, y=0.0456, z=0.0789[2023-01-01 12:00:01] [IMU Data] x=0.0124, y=0.0455, z=0.0790...\n\n恭喜你！你已经成功地从ROS机器人获取了实时数据！\n第三部分：常见问题与排错 (FAQ)问题1：Python脚本报错 ConnectionRefusedError (连接被拒绝)\n原因A: 你忘记在机器人端启动rosbridge_server。解决方法: 在机器人端运行 roslaunch rosbridge_server rosbridge_websocket.launch\n原因B: test.py里的ws_url IP地址填错了，不是机器人的IP。解决方法: 重新检查机器人IP地址并更新脚本\n原因C: 机器人或你的电脑开启了防火墙，阻止了9090端口的通信。解决方法: 在机器人端关闭防火墙或开放9090端口sudo ufw disable  # 关闭防火墙（不推荐在生产环境使用）# 或者开放9090端口sudo ufw allow 9090/tcp\n\n问题2：rosbridge终端报错 Cannot infer topic type… not yet advertised\n唯一原因: 你没有启动发布&#x2F;imu话题的机器人节点(&#x2F;base_driver)，或者该节点启动后崩溃了。解决方法: 请务必先用 rostopic info /imu 确认数据源正常。检查机器人节点是否正确启动，查看节点日志排查问题。\n\n问题3：脚本能连接，也显示订阅成功，但就是不打印 [IMU Data]\n原因A: 话题名称写错了。解决方法: 请检查test.py中 &quot;topic&quot;: &quot;/imu&quot; 是否与 rostopic list 显示的完全一致。\n原因B: 机器人节点虽然启动了，但由于某种原因停止发布数据了。解决方法: 可以在机器人端用 rostopic echo /imu 监听一下，看看是否有数据滚动。\n原因C: JSON解析错误导致数据处理失败。解决方法: 打开调试模式 websocket.enableTrace(True) 查看详细的消息内容，检查数据格式是否符合预期。\n\n问题4：数据接收不稳定，经常断线\n原因: 网络连接不稳定或ROS消息发布频率过高。解决方法:\n\n优化网络环境，确保机器人和客户端在同一局域网且信号良好\n降低ROS话题发布频率\n调整订阅参数，增加队列长度和节流率：\n\nsubscribe_message = &#123;    &quot;op&quot;: &quot;subscribe&quot;,    &quot;topic&quot;: &quot;/imu&quot;,    &quot;throttle_rate&quot;: 200,  # 增加节流率到200ms    &quot;queue_length&quot;: 50,    # 增加队列长度到50    &quot;compression&quot;: &quot;cbor&quot;&#125;\n\n第四部分：进阶应用1. 订阅多个话题如果你需要同时订阅多个话题，只需在on_open函数中发送多个订阅消息：\ndef on_open(ws):    print(&quot;WebSocket连接已建立&quot;)      # 订阅IMU话题    ws.send(json.dumps(&#123;        &quot;op&quot;: &quot;subscribe&quot;,        &quot;topic&quot;: &quot;/imu&quot;,        &quot;throttle_rate&quot;: 100    &#125;))      # 订阅里程计话题    ws.send(json.dumps(&#123;        &quot;op&quot;: &quot;subscribe&quot;,        &quot;topic&quot;: &quot;/odom&quot;,        &quot;throttle_rate&quot;: 100    &#125;))      print(&quot;已订阅话题: /imu, /odom&quot;)\n\n2. 数据可视化使用matplotlib库可以实时绘制IMU数据曲线：\nimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationimport numpy as np# 初始化图形fig, ax = plt.subplots()x_data, y_data, z_data = [], [], []line_x, = ax.plot([], [], &#x27;r-&#x27;, label=&#x27;X&#x27;)line_y, = ax.plot([], [], &#x27;g-&#x27;, label=&#x27;Y&#x27;)line_z, = ax.plot([], [], &#x27;b-&#x27;, label=&#x27;Z&#x27;)ax.set_xlim(0, 100)ax.set_ylim(-10, 10)ax.legend()ax.set_title(&#x27;IMU加速度数据实时显示&#x27;)ax.set_xlabel(&#x27;时间&#x27;)ax.set_ylabel(&#x27;加速度 (m/s²)&#x27;)def update(frame):    line_x.set_data(range(len(x_data)), x_data)    line_y.set_data(range(len(y_data)), y_data)    line_z.set_data(range(len(z_data)), z_data)    if len(x_data) &gt; 100:        ax.set_xlim(len(x_data)-100, len(x_data))    return line_x, line_y, line_zdef on_message(ws, message):    try:        data = json.loads(message)        if &quot;msg&quot; in data and &#x27;linear_acceleration&#x27; in data[&#x27;msg&#x27;]:            imu_data = data[&#x27;msg&#x27;]            x = imu_data[&#x27;linear_acceleration&#x27;][&#x27;x&#x27;]            y = imu_data[&#x27;linear_acceleration&#x27;][&#x27;y&#x27;]            z = imu_data[&#x27;linear_acceleration&#x27;][&#x27;z&#x27;]                      # 更新数据            x_data.append(x)            y_data.append(y)            z_data.append(z)                      # 限制数据点数量，避免内存溢出            if len(x_data) &gt; 200:                x_data.pop(0)                y_data.pop(0)                z_data.pop(0)                  except json.JSONDecodeError as e:        print(f&quot;[JSON解析错误] &#123;e&#125;: &#123;message&#125;&quot;)# 创建动画ani = FuncAnimation(fig, update, interval=100)# 启动WebSocket和图形显示if __name__ == &quot;__main__&quot;:    # ... (保持原有代码不变)      # 在单独线程中启动图形显示    import threading    thread = threading.Thread(target=plt.show)    thread.daemon = True    thread.start()      # 启动WebSocket客户端    ws.run_forever()\n\n3. 发送命令到ROS除了订阅话题接收数据，你还可以通过WebSocket向ROS发布消息：\ndef send_command(ws, topic, message_type, data):    &quot;&quot;&quot;向ROS发布消息&quot;&quot;&quot;    publish_msg = &#123;        &quot;op&quot;: &quot;publish&quot;,        &quot;topic&quot;: topic,        &quot;type&quot;: message_type,        &quot;msg&quot;: data    &#125;    ws.send(json.dumps(publish_msg))# 示例：发布速度命令def on_open(ws):    print(&quot;WebSocket连接已建立&quot;)    # 订阅IMU话题    ws.send(json.dumps(&#123;        &quot;op&quot;: &quot;subscribe&quot;,        &quot;topic&quot;: &quot;/imu&quot;    &#125;))      # 发布速度命令    send_command(        ws,         &quot;/cmd_vel&quot;,         &quot;geometry_msgs/Twist&quot;,         &#123;            &quot;linear&quot;: &#123;&quot;x&quot;: 0.1, &quot;y&quot;: 0.0, &quot;z&quot;: 0.0&#125;,            &quot;angular&quot;: &#123;&quot;x&quot;: 0.0, &quot;y&quot;: 0.0, &quot;z&quot;: 0.2&#125;        &#125;    )\n\n通过这些步骤和代码，你不仅可以获取ROS机器人的实时数据，还可以实现数据可视化和机器人控制，为开发更复杂的机器人应用打下基础。\n"},{"title":"在ROS Melodic环境中配置Python 3.6并运行Gazebo脚本的详细教程","url":"/2025/07/27/%E5%9C%A8ROS-Melodic%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%85%8D%E7%BD%AEPython-3-6%E5%B9%B6%E8%BF%90%E8%A1%8CGazebo%E8%84%9A%E6%9C%AC%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/","content":"在ROS Melodic环境中配置Python 3.6并运行Gazebo脚本的详细教程一、问题背景与初始错误分析1.1 错误现象当尝试在Python 2.7环境下运行包含f-string语法的Gazebo脚本时，系统会抛出以下错误：\nSyntaxError: invalid syntax  File &quot;/home/bobac3/gazebo/gazebo_test_ws/src/gazebo_pkg/script/random_model_for_room.py&quot;, line 43    &#123;&quot;name_prefix&quot;: &quot;fruit_board_&quot;, &quot;path&quot;: f&quot;/home/bobac3/.gazebo/models/&#123;random.choice(fruit_board_folders)&#125;/model.sdf&quot;&#125;,                                                                                                                        ^\n\n1.2 错误原因\nf-string语法是Python 3.6及以上版本的特性\nROS Melodic默认使用Python 2.7环境\n需要在不修改原代码的前提下，将运行环境切换至Python 3.6\n\n二、环境准备：安装与切换Python 3.62.1 检查系统已安装的Python版本# 列出系统中所有Python相关可执行文件ls /usr/bin/python*# 示例输出（可能包含以下内容）：# /usr/bin/python  /usr/bin/python2  /usr/bin/python2.7  /usr/bin/python3  /usr/bin/python3.6  /usr/bin/python3.6m# 定位Python 3.6的安装路径which python3.6# 示例输出：# /usr/bin/python3.6\n\n2.2 安装Python 3.6（若未安装）2.2.1 Ubuntu&#x2F;Debian系统安装方法# 添加第三方PPA源（包含Python 3.6包）sudo add-apt-repository ppa:deadsnakes/ppa# 更新软件包索引sudo apt update# 安装Python 3.6及虚拟环境工具sudo apt install python3.6 python3.6-venv# 验证安装结果python3.6 --version# 应输出：Python 3.6.x\n\n2.2.2 CentOS&#x2F;RHEL系统安装方法# 安装CentOS软件集合（Software Collections）sudo yum install centos-release-scl# 安装Python 3.6软件集合sudo yum install rh-python36# 临时激活Python 3.6环境（当前终端有效）scl enable rh-python36 bash# 验证环境python --version# 应输出：Python 3.6.x\n\n2.3 创建并管理Python 3.6虚拟环境2.3.1 创建独立虚拟环境# 在gazebo目录下创建虚拟环境（避免与系统环境冲突）python3.6 -m venv ~/gazebo/venv_py36# 虚拟环境目录结构说明：# venv_py36/# ├── bin/              # 包含python解释器和pip工具# ├── include/          # Python头文件# ├── lib/              # 安装的Python包# └── pyvenv.cfg        # 环境配置文件\n\n2.3.2 激活虚拟环境# 激活虚拟环境（每次新终端需重新执行）source ~/gazebo/venv_py36/bin/activate# 激活后终端前缀会显示虚拟环境名称# 示例：(venv_py36) bobac3@reinovo:~$ # 退出虚拟环境deactivate\n\n2.3.3 验证Python版本# 检查当前环境Python版本python --version# 应输出Python 3.6.x# 检查pip版本（确保兼容Python 3.6）pip --version# 示例输出：pip 20.0.2 from ... (python 3.6)\n\n三、配置ROS Melodic与Python 3.6兼容3.1 安装ROS Python 3依赖包# 安装ROS Python 3兼容性模块sudo apt install python3-catkin-pkg-modules python3-rospkg-modules python3-empy# 包功能说明：# python3-catkin-pkg-modules - Catkin构建系统的Python 3接口# python3-rospkg-modules     - ROS包管理系统的Python 3接口# python3-empy              - ROS模板引擎（兼容Python 3）\n\n3.2 重新编译catkin工作空间3.2.1 清除旧编译文件# 进入工作空间cd ~/gazebo/gazebo_test_ws# 清除旧编译产物（可选，但推荐执行）catkin clean# 执行后会删除build/和devel/目录\n\n3.2.2 配置Python 3.6路径# 使用catkin config命令指定Python 3.6catkin config --cmake-args \\  -DPYTHON_EXECUTABLE=~/gazebo/venv_py36/bin/python \\  -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m \\  -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so# 参数说明：# -DPYTHON_EXECUTABLE: 指定Python解释器路径# -DPYTHON_INCLUDE_DIR: 指定Python头文件目录# -DPYTHON_LIBRARY: 指定Python库文件路径（根据系统架构可能需要调整）\n\n3.2.3 重新编译工作空间# 使用catkin build（推荐）或catkin_make编译catkin build# 编译过程说明：# 1. CMake生成构建文件# 2. 编译C++代码（如有）# 3. 生成Python模块和消息定义# 4. 创建devel空间链接\n\n3.3 激活工作空间与Python环境# 先激活ROS工作空间source ~/gazebo/gazebo_test_ws/devel/setup.bash# 再激活Python 3.6虚拟环境source ~/gazebo/venv_py36/bin/activate# 验证ROS Python版本echo $ROS_PYTHON_VERSION# 若未设置，可手动设置：export ROS_PYTHON_VERSION=3\n\n四、安装脚本依赖包4.1 安装基础依赖# 在虚拟环境中安装必要的Python包pip install pyyaml rospkg catkin_pkg empy wheel# 包功能说明：# pyyaml       - YAML解析器（ROS消息序列化依赖）# rospkg       - ROS包管理库# catkin_pkg   - Catkin构建系统库# empy         - 模板引擎（ROS生成消息时使用）# wheel        - Python二进制包格式，加速安装\n\n4.2 解决empy安装问题（常见错误处理）4.2.1 错误现象Building wheels for collected packages: empy  Running setup.py bdist_wheel for empy ... error  error: invalid command &#x27;bdist_wheel&#x27;\n\n4.2.2 解决方案# 更新setuptools和pip到最新版本pip install --upgrade setuptools pip# 卸载旧版本empypip uninstall -y empy# 重新安装empy（使用wheel格式）pip install empy# 验证安装python -c &quot;import em; print(em.__version__)&quot;# 应输出empy版本号（如4.2）\n\n五、运行脚本与解决文件路径问题5.1 运行脚本与错误定位# 执行Gazebo模型生成脚本python ~/gazebo/gazebo_test_ws/src/gazebo_pkg/script/random_model_for_room.py# 可能遇到的错误：Traceback (most recent call last):  File &quot;.../random_model_for_room.py&quot;, line 51, in &lt;module&gt;    for config in model_configs  File &quot;.../random_model_for_room.py&quot;, line 14, in load_model    with open(model_path, &#x27;r&#x27;) as model_file:FileNotFoundError: [Errno 2] No such file or directory: &#x27;/home/bobac3/.gazebo/models/fruit2_board/model.sdf&#x27;\n\n5.2 解决模型文件缺失问题5.2.1 检查模型文件存在性# 方法1：直接检查文件路径ls -la ~/.gazebo/models/fruit2_board/model.sdf# 方法2：列出所有水果板模型ls ~/.gazebo/models | grep &quot;fruit.*board&quot;# 示例输出（假设存在fruit1_board和fruit3_board）：# fruit1_board  fruit3_board\n\n5.2.2 修改代码添加路径验证# 在脚本中导入os模块import os# 修改load_model函数，添加路径检查def load_model(model_path):    # 验证路径有效性    if not os.path.exists(model_path):        rospy.logerr(f&quot;错误：模型文件不存在 - &#123;model_path&#125;&quot;)        return None      try:        with open(model_path, &#x27;r&#x27;) as model_file:            return model_file.read()    except Exception as e:        rospy.logerr(f&quot;加载模型失败：&#123;str(e)&#125;&quot;)        return None\n\n5.2.3 更新模型配置列表# 修改model_configs列表，使用存在的模型路径model_configs = [    &#123;        &quot;name_prefix&quot;: &quot;fruit_board_&quot;,        # 从存在的模型文件夹中随机选择        &quot;path&quot;: f&quot;/home/bobac3/.gazebo/models/&#123;random.choice([&#x27;fruit1_board&#x27;, &#x27;fruit3_board&#x27;])&#125;/model.sdf&quot;    &#125;,    # 其他模型配置...]\n\n5.2.4 设置Gazebo模型路径（可选）# 临时设置Gazebo模型搜索路径export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:~/custom_models# 或在代码中动态设置import osos.environ[&quot;GAZEBO_MODEL_PATH&quot;] = &quot;~/custom_models:&quot; + os.environ.get(&quot;GAZEBO_MODEL_PATH&quot;, &quot;&quot;)\n\n六、优化工作流程与便捷操作6.1 创建环境激活脚本# 创建脚本文件nano ~/gazebo/activate_ros_py36.sh# 写入以下内容#!/bin/bash# 激活Python 3.6虚拟环境source ~/gazebo/venv_py36/bin/activate# 激活ROS工作空间source ~/gazebo/gazebo_test_ws/devel/setup.bash# 设置ROS Python版本export ROS_PYTHON_VERSION=3# 打印提示信息echo &quot;=====================================&quot;echo &quot;  Python 3.6环境与ROS Melodic已激活&quot;echo &quot;  当前Python版本: $(python --version)&quot;echo &quot;  ROS工作空间: ~/gazebo/gazebo_test_ws&quot;echo &quot;=====================================&quot;# 保存并退出（Ctrl+X，Y，Enter）# 添加执行权限chmod +x ~/gazebo/activate_ros_py36.sh# 执行脚本激活环境./activate_ros_py36.sh\n\n6.2 使用roslaunch运行脚本6.2.1 创建launch文件# 创建launch目录（若不存在）mkdir -p ~/gazebo/gazebo_test_ws/src/gazebo_pkg/launch# 创建random_model.launch文件nano ~/gazebo/gazebo_test_ws/src/gazebo_pkg/launch/random_model.launch\n\n6.2.2 编写launch文件内容&lt;launch&gt;  &lt;!-- 运行Gazebo模型生成脚本 --&gt;  &lt;node     name=&quot;random_model_generator&quot;    pkg=&quot;gazebo_pkg&quot;    type=&quot;random_model_for_room.py&quot;    output=&quot;screen&quot;      &lt;!-- 可选：设置环境变量 --&gt;    env=&quot;ROS_PYTHON_VERSION=3&quot;  /&gt;&lt;/launch&gt;\n\n6.2.3 编译并运行launch文件# 重新编译工作空间（确保launch文件被识别）cd ~/gazebo/gazebo_test_wscatkin build# 激活环境并运行launchsource ~/gazebo/activate_ros_py36.shroslaunch gazebo_pkg random_model.launch\n\n七、常见问题与高级解决方案7.1 ModuleNotFoundError: No module named ‘yaml’问题原因\nPython 3.6虚拟环境中未安装pyyaml包\n\n解决方案# 在虚拟环境中安装pyyamlpip install pyyaml# 验证安装python -c &quot;import yaml; print(yaml.__version__)&quot;\n\n7.2 ROS消息生成错误（Python 3兼容问题）问题现象error: invalid command &#x27;bdist_wheel&#x27;或ImportError: cannot import name &#x27;message&#x27; from &#x27;genpy&#x27;\n\n解决方案# 安装ROS Python 3扩展包pip install -U rospkg catkin_pkg empy# 重新配置catkin工作空间catkin config --cmake-args \\  -DPYTHON_EXECUTABLE=~/gazebo/venv_py36/bin/python \\  -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m \\  -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so  catkin build\n\n7.3 模型路径动态检测优化优化脚本（自动扫描可用模型）import osimport randomdef get_available_models(base_path):    &quot;&quot;&quot;扫描目录获取所有可用模型文件夹&quot;&quot;&quot;    if not os.path.exists(base_path):        return []      # 过滤出包含model.sdf的文件夹    available_models = []    for folder in os.listdir(base_path):        folder_path = os.path.join(base_path, folder)        if os.path.isdir(folder_path) and os.path.exists(os.path.join(folder_path, &quot;model.sdf&quot;)):            available_models.append(folder)      return available_models# 使用示例base_model_path = &quot;/home/bobac3/.gazebo/models&quot;fruit_board_folders = get_available_models(base_model_path)if not fruit_board_folders:    rospy.logfatal(&quot;未找到任何Gazebo模型！请检查模型路径。&quot;)    sys.exit(1)# 后续使用random.choice(fruit_board_folders)选择模型\n\n八、环境验证与最佳实践8.1 完整环境验证流程\n激活环境：./activate_ros_py36.sh\n验证Python版本：python --version → Python 3.6.x\n验证ROS包：rospack list | grep gazebo_pkg\n运行脚本：roslaunch gazebo_pkg random_model.launch\n检查Gazebo界面是否加载模型\n\n8.2 最佳实践建议\n隔离环境：始终使用虚拟环境避免系统依赖冲突\n版本控制：将环境配置（如requirements.txt）加入版本控制\n日志记录：在脚本中添加详细日志以便调试\n定期更新：保持pip、setuptools等工具为最新版本\n备份模型：重要模型建议备份到版本控制或独立目录\n\n通过以上步骤，您可以在ROS Melodic环境中成功配置Python 3.6并运行Gazebo脚本，同时解决依赖管理和文件路径问题，建立稳定的开发工作流。\n"}]